plugins {
	id 'com.mydata.springboot-webflux-conventions'
}

group = 'com.mydata.userdata'
version = '0.0.1'
sourceCompatibility = '17'

dependencies {
	implementation project(":utilities")
	implementation 'io.r2dbc:r2dbc-postgresql'
	implementation 'org.springframework.boot:spring-boot-starter-data-r2dbc'
	testImplementation 'org.testcontainers:postgresql'
	testImplementation 'org.testcontainers:r2dbc'
	testRuntimeOnly 'org.postgresql:postgresql'
}

ext {
	def ENV = System.getenv()
}

application {
	mainClass = 'com.mydata.userdata.UserDataApplication'
}

def jacocoExlude = ['com.mydata.userdata.UserDataApplication', 'com.mydata.userdata.entity.*']
jacocoTestCoverageVerification.violationRules(vr -> vr.rules.forEach(rule -> rule.excludes = jacocoExlude))

contracts {
	testFramework = "JUNIT5"
	testMode = "EXPLICIT"
	packageWithBaseClasses = 'com.mydata.userdata.contract'
}

contractTest {
	useJUnitPlatform()
	testLogging {
		exceptionFormat = 'full'
	}
	afterSuite { desc, result ->
		if (!desc.parent) {
			println "Results: (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
			boolean skipTests = Boolean.parseBoolean(project.findProperty('SKIP_TESTS').toString() ?: "false")
			if (result.testCount == 0 && !skipTests) {
				throw new IllegalStateException("No tests were found. Failing the build")
			}
		}
	}
}

//Disable pmdContractTest
pmdContractTest.onlyIf { false }

sourceSets {
	sql {
	}
}

def generateInitSql = tasks.register('generateInitSql') {
	doLast {
		def initTestSqlFileName = 'db-init.sql'
		def runFirstSqlFiles = ['MutualFund.sql', 'Stock.sql']
		def outputFile = new File(sourceSets.test.output.resourcesDir.getPath() + '/' + initTestSqlFileName)
		//Clear File content before inserting contents
		outputFile.text = ''
		outputFile.withWriter {
			writer ->
				writer.write('--Start DB Initialization\n')
				def orderedSql = new LinkedList<>()
				def index = runFirstSqlFiles.size()
				sourceSets.sql.resources.getSourceDirectories().getFiles().first().eachFileRecurse {
					file ->
						file.withReader {
							reader ->
								{
									if (runFirstSqlFiles.contains(file.name)) {
										orderedSql[runFirstSqlFiles.indexOf(file.name)] = reader.getText()
									} else {
										orderedSql[index++] = reader.getText()
									}
								}
						}
				}
				orderedSql.each {
					test ->
						writer << test << '\n'
				}
				writer << new File(sourceSets.test.output.resourcesDir.getPath() + '/sql/' + initTestSqlFileName).newReader() << '\n'
		}
	}
}

processTestResources.finalizedBy(generateInitSql)
